# 选择性关注周围的事件（_choose_retrieved）

将操作对象称为“主角”

这里采用的是排除法，排除掉那些不值得关注的事件，从值得关注的事件中随机选择一件事情关注。

1. 不关注自身的一些状态，因此把和自己有关的事件排除。过滤掉以主角为主语的事件
2. 除此之外，优先看看环境里面有没有其他人，如果有，那么就关注那个人相关的事件。
3. 如果周围的环境里面没有人，就关注环境中物品的状态（跳过空闲的物品）。
4. 如果什么都没有，就不关注了（return None）。

输入包括 角色名 和 检索事件得到的输出（使用了 检索事件的主语subject字段）

输出为 None 或者 某个特定的事件（curr_event）

```python
def _choose_retrieved(role_name: str, retrieved: dict) -> Union[None, dict]:
    """
    选择性关注周围的事件
    检索到的元素可能有多个“curr_event”，这个函数负责选择一个事件，此事件是当前人物需要做出反应的事件
    输入包括角色名和检索周围事件的输出
    Args:
      role_name: 当前的人物名
      retrieved: 从人物社交记忆中检索到的概念（<ConceptNode>）字典，字典有以下结构：
                 dictionary[event.description] =
                   {["curr_event"] = <ConceptNode>,
                    ["events"] = [<ConceptNode>, ...],
                    ["thoughts"] = [<ConceptNode>, ...] }
    Returns:
        None | dict
        dict: {"curr_event":<ConceptNode>, "events":[<ConceptNode>,,,], "thoughts":[ConceptNode]}
    """
    # 过滤掉当前人物为主语的事件
    copy_retrieved = retrieved.copy()
    for event_desc, rel_ctx in copy_retrieved.items():
        curr_event = rel_ctx["curr_event"]
        if curr_event.subject == role_name:
            del retrieved[event_desc]

    # Always choose role first.
    priority = []
    for event_desc, rel_ctx in retrieved.items():
        curr_event = rel_ctx["curr_event"]
        # 当前事件的主语是人
        if ":" not in curr_event.subject and curr_event.subject != role_name:
            priority += [rel_ctx]
            
    # 随机选一个以人为主语事件
    if priority:
        return random.choice(priority)

    # Skip idle.
    # 跳过处于空闲状态的物品
    for event_desc, rel_ctx in retrieved.items():
        if "is idle" not in event_desc:
            priority += [rel_ctx]
    if priority:
        return random.choice(priority)
    
    # 没有事件则不关注事件
    return None
```



# 确定回应形式（_should_react）

输入：上一次选择关注的事件，主角角色类，其他角色的角色类

返回值：False(bool)  |  "chat with {someone}"  |  "wait: {time stamp}"

先根据条件筛选掉一些不需要回应的情况，再通过大模型确定具体的回应形式

1. 如果主角正在谈话或者等待（waiting），不回应
2. 关注到的事件的主语是物品，不回应

```python
    # 如果人物当前在对话或者在等待做某事，默认不对其他事件做出反应 scratch表示角色信息类
    scratch = role.rc.scratch
    if scratch.chatting_with:
        return False
    if "<waiting>" in scratch.act_address:
        return False
    
    # 判断 curr_event 主语是物品
    if ":" in curr_event.subject:
        return False
```

通过大模型判断是否需要回应，先判断是否交谈，再判断是否等待

## 判断是否交谈：

生成角色信息以及上下文信息，通过大模型决定是否需要和目标角色进行交谈

```python
    async def lets_talk(init_role , target_role , retrieved: dict):
        # 不与自己对话
        if init_role.name == target_role.name:
            # logger.info(f"Role: {role.name} _should_react lets_talk meet same role, return False")
            return False

        # 人物动作信息
        scratch = init_role.rc.scratch
        # 对象动作信息
        target_scratch = target_role.rc.scratch
        
        # 二者信息动作信息不全
        if (
            not target_scratch.act_address
            or not target_scratch.act_description
            or not scratch.act_address
            or not scratch.act_description
        ):
            return False

        # 某一方在睡觉
        if "sleeping" in target_scratch.act_description or "sleeping" in scratch.act_description:
            return False

        # 动作时间为23点 太晚了
        if scratch.curr_time.hour == 23:
            return False

        # 对象在等待做某事 不要打扰
        if "<waiting>" in target_scratch.act_address:
            return False

        # 某一方目前正在与人交谈 不要打扰
        if target_scratch.chatting_with or scratch.chatting_with:
            return False

        # 聊天冷却期 可能不久之前才聊过天
        if target_role.name in scratch.chatting_with_buffer:
            if scratch.chatting_with_buffer[target_role.name] > 0:
                return False

        if await DecideToTalk().run(init_role, target_role, retrieved):
            return True

        return False
```

先过滤掉不交谈的情况，再调用大模型。调用大模型需要构造特定内容的场景提示词，用到的信息有：

1. 从记忆(AssociativeMemory)中查询的角色上一次交谈的时间 
2. 角色动作信息（scratch）
3. 角色名

包括：当前时间curr_time, 行为描述act_description, 计划路径planned_path, 动作地点act_address, 

## 判断是否等待

生成角色信息以及上下文信息，然后交给大模型判断角色 继续做当前的事情 还是 等待知道目标角色做完某事

```python
    async def lets_react(init_role , target_role , retrieved: dict):
        if init_role.name == target_role.name:
            # logger.info(f"Role: {role.name} _should_react lets_react meet same role, return False")
            return False

        scratch = init_role.rc.scratch
        target_scratch = target_role.rc.scratch
        # 二者信息动作信息不全
        if (
            not target_scratch.act_address
            or not target_scratch.act_description
            or not scratch.act_address
            or not scratch.act_description
        ):
            return False
        
        # 某一方在睡觉
        if "sleeping" in target_scratch.act_description or "sleeping" in scratch.act_description:
            return False

        # 动作时间为23点 太晚了
        if scratch.curr_time.hour == 23:
            return False

        # 对象在等待做某事 不要打扰
        if "waiting" in target_scratch.act_description:
            return False
        # 计划为空
        if scratch.planned_path == []:
            return False
        
        # 二者地点不一样
        if scratch.act_address != target_scratch.act_address:
            return False

        react_mode = await DecideToReact().run(init_role, target_role, retrieved)

        if react_mode == "1":
            wait_until = (
                target_scratch.act_start_time + datetime.timedelta(minutes=target_scratch.act_duration - 1)
            ).strftime("%B %d, %Y, %H:%M:%S")
            return f"wait: {wait_until}"
        elif react_mode == "2":
            return False
        else:
            return False  # "keep"
```

先过滤掉不等待的情况，再通过大模型确定是否等待，用到的信息有：

​	角色动作信息（scratch）,  角色名称

包括：当前时间curr_time, 行为描述act_description, 计划路径planned_path, 动作地点act_address, 